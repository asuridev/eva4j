const fs = require('fs-extra');
const path = require('path');
const { renderAndWrite } = require('../utils/template-engine');

class ModuleGenerator {
  constructor(context) {
    this.context = context;
    this.templatesDir = path.join(__dirname, '../../templates/module');
    this.projectDir = process.cwd();
  }

  async generate() {
    const { packagePath, moduleName } = this.context;
    const moduleBasePath = path.join(this.projectDir, 'src', 'main', 'java', packagePath, moduleName);
    
    // Create module directories with application subdirectories
    await fs.ensureDir(path.join(moduleBasePath, 'application', 'commands'));
    await fs.ensureDir(path.join(moduleBasePath, 'application', 'dtos'));
    await fs.ensureDir(path.join(moduleBasePath, 'application', 'mappers'));
    await fs.ensureDir(path.join(moduleBasePath, 'application', 'events'));
    await fs.ensureDir(path.join(moduleBasePath, 'application', 'ports'));
    await fs.ensureDir(path.join(moduleBasePath, 'application', 'queries'));
    await fs.ensureDir(path.join(moduleBasePath, 'application', 'usecases'));
    
    // Create domain subdirectories
    await fs.ensureDir(path.join(moduleBasePath, 'domain', 'models', 'entities'));
    await fs.ensureDir(path.join(moduleBasePath, 'domain', 'models', 'valueObjects'));
    await fs.ensureDir(path.join(moduleBasePath, 'domain', 'models', 'events'));
    await fs.ensureDir(path.join(moduleBasePath, 'domain', 'repositories'));
    await fs.ensureDir(path.join(moduleBasePath, 'domain', 'services'));
    
    // Create infrastructure subdirectories
    await fs.ensureDir(path.join(moduleBasePath, 'infrastructure', 'adapters'));
    await fs.ensureDir(path.join(moduleBasePath, 'infrastructure', 'database'));
    await fs.ensureDir(path.join(moduleBasePath, 'infrastructure', 'rest', 'controllers'));
    await fs.ensureDir(path.join(moduleBasePath, 'infrastructure', 'rest', 'validators'));
    
    // Generate package-info.java at module root
    await this.generateFile('package-info.java.ejs', 
      path.join(moduleBasePath, 'package-info.java'));
    
    // Generate domain.yaml template at module root
    await this.generateDomainYamlTemplate(moduleBasePath);
  }

  async generateDomainYamlTemplate(moduleBasePath) {
    const { moduleName, moduleDisplayName } = this.context;
    const displayName = moduleDisplayName || moduleName;
    
    const domainYamlContent = `# Domain Model Definition for ${displayName} module
# Generated by eva4j - Complete this template with your domain model

aggregates:
  # Example aggregate - rename and customize for your domain
  - name: ExampleAggregate
    entities:
      # Root entity - required, one per aggregate
      - name: ExampleEntity
        isRoot: true
        fields:
          # ID field - required for all entities
          - name: id
            type: Long  # or UUID, String, Integer
            
          # Example fields - customize for your domain
          - name: name
            type: String
            
          - name: description
            type: String
            
          - name: status
            type: ExampleStatus  # references enum below
            
          - name: createdAt
            type: LocalDateTime
            
        # One-to-Many relationships - uncomment and customize
        # relationships:
        #   - entityName: ExampleItem
        #     type: OneToMany
        #     fieldName: items
        #     cascade: [PERSIST, MERGE, REMOVE]  # Controls child entity persistence
        #     fetch: LAZY  # or EAGER - LAZY is recommended for collections
      
      # Secondary entity example - uncomment to add child entities
      # - name: ExampleItem
      #   isRoot: false
      #   fields:
      #     - name: id
      #       type: Long
      #     - name: itemName
      #       type: String
      #     - name: quantity
      #       type: Integer
      #     - name: price
      #       type: BigDecimal
      #   
      #   # Nested relationships - supports multi-level nesting
      #   # relationships:
      #   #   - entityName: ExampleOption
      #   #     type: OneToMany
      #   #     fieldName: options
      #   #     cascade: [PERSIST, MERGE, REMOVE]
      #   #     fetch: LAZY
    
    # Value Objects - uncomment to add embedded objects
    # valueObjects:
    #   - name: Money
    #     fields:
    #       - name: amount
    #         type: BigDecimal
    #       - name: currency
    #         type: String
    #   
    #   - name: Address
    #     fields:
    #       - name: street
    #         type: String
    #       - name: city
    #         type: String
    #       - name: zipCode
    #         type: String
    
    # Enums - required if referenced in entity fields
    enums:
      - name: ExampleStatus
        values:
          - ACTIVE
          - INACTIVE
          - PENDING

# ðŸ“š Tips:
# - isRoot: true is required for exactly ONE entity per aggregate
# - cascade: Controls automatic persistence of child entities
#   * PERSIST: Save children when parent is saved
#   * MERGE: Update children when parent is updated  
#   * REMOVE: Delete children when parent is deleted
#   * ALL: Applies all operations (use with caution)
# - fetch: Controls when relationships are loaded
#   * LAZY: Load on demand (recommended for collections)
#   * EAGER: Load immediately with parent (use sparingly)
# - Supported types: String, Integer, Long, Double, BigDecimal, Boolean,
#   LocalDate, LocalDateTime, LocalTime, UUID, or custom enums
# - For complete documentation, see: DOMAIN_YAML_GUIDE.md
`;
    
    const domainYamlPath = path.join(moduleBasePath, 'domain.yaml');
    await fs.writeFile(domainYamlPath, domainYamlContent, 'utf-8');
    console.log(`âœ“ Created domain.yaml template at ${path.relative(this.projectDir, domainYamlPath)}`);
  }

  async generateFile(templateRelPath, destPath) {
    const templatePath = path.join(this.templatesDir, templateRelPath);
    await renderAndWrite(templatePath, destPath, this.context);
  }
}

module.exports = ModuleGenerator;
