'use strict';

const crypto = require('crypto');
const fs = require('fs-extra');
const path = require('path');

const CHECKSUMS_FILE = '.eva4j-checksums.json';

/**
 * Tracks SHA-256 checksums of generated files so that manually-modified files
 * can be identified and protected from being overwritten on re-generation.
 *
 * Lifecycle per command run:
 *   1. new ChecksumManager(moduleBasePath)
 *   2. await manager.load()
 *   3. Pass instance to every renderAndWrite() call
 *   4. await manager.save()            ← persists updates to disk
 */
class ChecksumManager {
  /**
   * @param {string} moduleBasePath - Absolute path to the module root directory
   *   (the directory that contains domain.yaml). The checksums file will be
   *   stored here as `.eva4j-checksums.json`.
   */
  constructor(moduleBasePath) {
    this._filePath = path.join(moduleBasePath, CHECKSUMS_FILE);
    /** @type {Record<string, string>} key = absolute normalised path, value = sha256 hex */
    this._checksums = {};
    /** @type {Record<string, string>} pending writes — merged into _checksums on save() */
    this._pending = {};
  }

  /**
   * Load existing checksums from disk (if the file exists).
   * Safe to call even when the file does not yet exist.
   */
  async load() {
    try {
      if (await fs.pathExists(this._filePath)) {
        const raw = await fs.readFile(this._filePath, 'utf-8');
        this._checksums = JSON.parse(raw);
      }
    } catch {
      // Corrupted file — start fresh; it will be recreated on save()
      this._checksums = {};
    }
  }

  /**
   * Compute SHA-256 hash of a string.
   * @param {string} content
   * @returns {string} hex digest
   */
  computeHash(content) {
    return crypto.createHash('sha256').update(content, 'utf-8').digest('hex');
  }

  /**
   * Normalise a file path to a consistent key (forward slashes, lower-caseable
   * on case-insensitive file systems).  We keep the original case so the key
   * is human-readable, but normalise separators.
   * @param {string} filePath
   * @returns {string}
   */
  _key(filePath) {
    return path.resolve(filePath).split(path.sep).join('/');
  }

  /**
   * Returns true when:
   *   - the file exists on disk, AND
   *   - the file has been recorded in the checksums database, AND
   *   - the current on-disk content differs from the recorded checksum
   *     (i.e. the developer edited the file manually).
   *
   * Returns false when:
   *   - the file does not exist yet (new file)
   *   - the file was never recorded (legacy file — treat as unmodified)
   *   - the file content matches the recorded checksum (unmodified generated file)
   *
   * @param {string} destPath  Absolute path to the file
   * @param {string} generatedContent  The freshly rendered content (not yet written)
   * @returns {Promise<boolean>}
   */
  async wasModified(destPath, generatedContent) {
    const key = this._key(destPath);
    const knownHash = this._checksums[key];

    // Not tracked — never been generated by eva4j, treat as unmodified
    if (!knownHash) return false;

    // File was removed — treat as unmodified (will recreate)
    if (!(await fs.pathExists(destPath))) return false;

    const diskContent = await fs.readFile(destPath, 'utf-8');
    const diskHash = this.computeHash(diskContent);

    // If disk hash matches stored hash, the file hasn't been touched
    if (diskHash === knownHash) return false;

    // Disk hash differs from stored hash — developer edited the file
    return true;
  }

  /**
   * Record the hash of content that is about to be written to destPath.
   * Call this AFTER the file has been written to disk so the hash reflects
   * the exact bytes on disk.
   *
   * @param {string} destPath
   * @param {string} content  The content that was written
   */
  recordWrite(destPath, content) {
    const key = this._key(destPath);
    const hash = this.computeHash(content);
    this._pending[key] = hash;
  }

  /**
   * Persist the updated checksums (merging pending writes) to disk.
   */
  async save() {
    Object.assign(this._checksums, this._pending);
    this._pending = {};
    await fs.ensureDir(path.dirname(this._filePath));
    await fs.writeFile(this._filePath, JSON.stringify(this._checksums, null, 2), 'utf-8');
  }
}

module.exports = ChecksumManager;
