package <%= packageName %>.shared.infrastructure.configurations.useCaseConfig;


import <%= packageName %>.shared.domain.interfaces.CommandHandler;
import <%= packageName %>.shared.domain.interfaces.Dispatchable;
import <%= packageName %>.shared.domain.interfaces.QueryHandler;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.ApplicationContext;
import org.springframework.stereotype.Component;

import java.lang.reflect.ParameterizedType;
import java.util.Map;

@Component
public class UseCaseAutoRegister implements CommandLineRunner {

  private final UseCaseContainer useCaseContainer;
  private final ApplicationContext applicationContext;

  public UseCaseAutoRegister(
          UseCaseContainer useCaseContainer,
          ApplicationContext applicationContext
  ) {
    this.useCaseContainer = useCaseContainer;
    this.applicationContext = applicationContext;
  }

  @Override
  public void run(String... args) throws Exception {
    // Registrar todos los CommandHandlers
    Map<String, CommandHandler> commandHandlers = applicationContext.getBeansOfType(CommandHandler.class);
    commandHandlers.values().forEach(handler -> {
      Class<Dispatchable> commandType = getGenericType(handler.getClass());
      useCaseContainer.register(commandType, handler);
    });
    // Registrar todos los QueryHandlers
    Map<String, QueryHandler> queryHandlers = applicationContext.getBeansOfType(QueryHandler.class);
    queryHandlers.values().forEach(handler -> {
      Class<Dispatchable> queryType = getGenericType(handler.getClass());
      useCaseContainer.register(queryType, handler);
    });
  }

  @SuppressWarnings("unchecked")
  private Class<Dispatchable> getGenericType(Class<?> handlerClass) {
    // Traverse class hierarchy to find ParameterizedType (handles Spring proxies)
    Class<?> currentClass = handlerClass;
    
    while (currentClass != null) {
      // Check generic interfaces
      for (java.lang.reflect.Type genericInterface : currentClass.getGenericInterfaces()) {
        if (genericInterface instanceof ParameterizedType) {
          ParameterizedType parameterizedType = (ParameterizedType) genericInterface;
          java.lang.reflect.Type rawType = parameterizedType.getRawType();
          
          // Check if it's CommandHandler or QueryHandler interface
          if (rawType instanceof Class<?>) {
            Class<?> interfaceClass = (Class<?>) rawType;
            if (CommandHandler.class.isAssignableFrom(interfaceClass) || 
                QueryHandler.class.isAssignableFrom(interfaceClass)) {
              return (Class<Dispatchable>) parameterizedType.getActualTypeArguments()[0];
            }
          }
        }
      }
      
      // Check generic superclass
      java.lang.reflect.Type genericSuperclass = currentClass.getGenericSuperclass();
      if (genericSuperclass instanceof ParameterizedType) {
        ParameterizedType parameterizedType = (ParameterizedType) genericSuperclass;
        java.lang.reflect.Type[] typeArgs = parameterizedType.getActualTypeArguments();
        if (typeArgs.length > 0 && typeArgs[0] instanceof Class) {
          Class<?> potentialType = (Class<?>) typeArgs[0];
          if (Dispatchable.class.isAssignableFrom(potentialType)) {
            return (Class<Dispatchable>) potentialType;
          }
        }
      }
      
      // Move to superclass
      currentClass = currentClass.getSuperclass();
    }
    
    throw new IllegalArgumentException("Cannot determine generic type for handler: " + handlerClass.getName());
  }

}
