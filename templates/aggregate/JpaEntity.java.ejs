package <%= packageName %>.<%= moduleName %>.infrastructure.database.entities;

import jakarta.persistence.*;
import lombok.*;
<% // Check if any field is a Value Object to conditionally import AttributeOverride %>
<% const hasValueObjects = fields.some(f => f.isValueObject); %>
<% if (hasValueObjects) { %>
import jakarta.persistence.AttributeOverride;
import jakarta.persistence.AttributeOverrides;
<% } %>
<% imports.forEach(imp => { %>
<%- imp %>
<% }); %>
<% if (valueObjects && valueObjects.length > 0) { %>
import <%= packageName %>.<%= moduleName %>.infrastructure.database.valueObjects.*;
<% } %>
<% if (audit && audit.enabled && audit.trackUser) { %>
import <%= packageName %>.shared.domain.FullAuditableEntity;
<% } else if (audit && audit.enabled) { %>
import <%= packageName %>.shared.domain.AuditableEntity;
<% } else if (auditable) { %>
import <%= packageName %>.shared.domain.AuditableEntity;
<% } %>

/**
 * <%= name %>Jpa - JPA Entity
 * Secondary entity in aggregate (with Lombok)
 */
@Entity
@Table(name = "<%= tableName %>")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class <%= name %>Jpa<% if (audit && audit.enabled && audit.trackUser) { %> extends FullAuditableEntity<% } else if (audit && audit.enabled) { %> extends AuditableEntity<% } else if (auditable) { %> extends AuditableEntity<% } %> {
    
<%
// Helper function to convert camelCase to snake_case
function toSnakeCase(str) {
  return str.replace(/([A-Z])/g, '_$1').toLowerCase();
}

// Filter out audit fields based on configuration
const auditFields = [];
if (auditable || (audit && audit.enabled)) {
  auditFields.push('createdAt', 'updatedAt');
}
if (audit && audit.trackUser) {
  auditFields.push('createdBy', 'updatedBy');
}
%>
<% fields.filter(f => !auditFields.includes(f.name)).forEach((field, index) => { %>
  <% if (field.isCollection) { %>
    @ElementCollection
    @CollectionTable(name = "<%= tableName %>_<%= field.name %>", joinColumns = @JoinColumn(name = "<%= name.toLowerCase() %>_id"))
    <% if (field.collectionElementType === 'String' || field.collectionElementType === 'Integer' || field.collectionElementType === 'Long' || field.collectionElementType === 'Double' || field.collectionElementType === 'BigDecimal') { %>
    @Column(name = "<%= field.name.replace(/([A-Z])/g, '_$1').toLowerCase() %>")
    <% } %>
    @Builder.Default
    private <%- field.javaTypeJpa %> <%= field.name %> = new ArrayList<>();
  <% } else if (field.isValueObject) { %>
    <% if (index === 0) { %>@Id
    <% if (field.javaType === 'String') { %>@GeneratedValue(strategy = GenerationType.UUID)
    <% } else if (field.javaType === 'Long' || field.javaType === 'Integer') { %>@GeneratedValue(strategy = GenerationType.IDENTITY)
    <% } %><% } %><% 
    // Find the Value Object definition to get its fields
    const vo = valueObjects && valueObjects.find(v => v.name === field.javaType);
    if (vo && vo.fields && vo.fields.length > 0) {
    %>@AttributeOverrides({
    <% vo.fields.forEach((voField, voIdx) => { %>        @AttributeOverride(name = "<%= voField.name %>", column = @Column(name = "<%= toSnakeCase(field.name) %>_<%= toSnakeCase(voField.name) %>"))<%= voIdx < vo.fields.length - 1 ? ',' : '' %>
    <% }); %>    })
    <% } %>@Embedded
    private <%- field.javaTypeJpa %> <%= field.name %>;
  <% } else if (enums && enums.find(e => e.name === field.javaType)) { %>
    <% if (index === 0) { %>@Id
    <% if (field.javaType === 'String') { %>@GeneratedValue(strategy = GenerationType.UUID)
    <% } else if (field.javaType === 'Long' || field.javaType === 'Integer') { %>@GeneratedValue(strategy = GenerationType.IDENTITY)
    <% } %><% } %>@Enumerated(EnumType.STRING)
    @Column(name = "<%= field.name.replace(/([A-Z])/g, '_$1').toLowerCase() %>")
    private <%- field.javaType %> <%= field.name %>;
  <% } else { %>
    <% if (index === 0) { %>@Id
    <% if (field.javaType === 'String') { %>@GeneratedValue(strategy = GenerationType.UUID)
    <% } else if (field.javaType === 'Long' || field.javaType === 'Integer') { %>@GeneratedValue(strategy = GenerationType.IDENTITY)
    <% } %><% } %>@Column(name = "<%= field.name.replace(/([A-Z])/g, '_$1').toLowerCase() %>")
    private <%- field.javaType %> <%= field.name %>;
  <% } %>
<% }); %>
<% relationships.forEach(rel => { %>
  <% if (rel.type === 'OneToMany') { %>
    @OneToMany(mappedBy = "<%= rel.mappedBy %>", cascade = {<% rel.cascade.forEach((c, idx) => { %>CascadeType.<%= c %><%= idx < rel.cascade.length - 1 ? ', ' : '' %><% }); %>}, fetch = FetchType.<%= rel.fetch %>)
    @Builder.Default
    private <%- rel.javaTypeJpa %> <%= rel.fieldName %> = new ArrayList<>();
  <% } else if (rel.type === 'ManyToOne') { %>
    @ManyToOne(fetch = FetchType.<%= rel.fetch %>)
    @JoinColumn(name = "<%= rel.joinColumn %>")
    private <%- rel.javaTypeJpa %> <%= rel.fieldName %>;
  <% } else if (rel.type === 'OneToOne') { %>
    <% if (rel.mappedBy) { %>
    @OneToOne(mappedBy = "<%= rel.mappedBy %>", cascade = {<% rel.cascade.forEach((c, idx) => { %>CascadeType.<%= c %><%= idx < rel.cascade.length - 1 ? ', ' : '' %><% }); %>}, fetch = FetchType.<%= rel.fetch %>)
    <% } else { %>
    @OneToOne(cascade = {<% rel.cascade.forEach((c, idx) => { %>CascadeType.<%= c %><%= idx < rel.cascade.length - 1 ? ', ' : '' %><% }); %>}, fetch = FetchType.<%= rel.fetch %>)
    @JoinColumn(name = "<%= rel.joinColumn %>")
    <% } %>
    private <%- rel.javaTypeJpa %> <%= rel.fieldName %>;
  <% } %>
<% }); %>
}
