package <%= packageName %>.<%= moduleName %>.domain.models.entities;

<% imports.forEach(imp => { %>
<%- imp %>
<% }); %>
<% if (valueObjects.length > 0) { %>
import <%= packageName %>.<%= moduleName %>.domain.models.valueObjects.*;
<% } %>
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * <%= name %> - Aggregate Root
 * Domain entity (pure Java class without Lombok)
 */
public class <%= name %> {
    
<% fields.forEach(field => { %>
  <% if (field.isCollection) { %>
    private <%- field.javaType %> <%= field.name %> = new ArrayList<>();
  <% } else { %>
    private <%- field.javaType %> <%= field.name %>;
  <% } %>
<% }); %>
<% const domainRelationships = relationships.filter(rel => !rel.isInverse); %>
<% domainRelationships.forEach(rel => { %>
  <% if (rel.isCollection) { %>
    private <%- rel.javaType %> <%= rel.fieldName %> = new ArrayList<>();
  <% } else { %>
    private <%- rel.javaType %> <%= rel.fieldName %>;
  <% } %>
<% }); %>

    // Full constructor (for reconstruction from persistence)
    public <%= name %>(<% let paramIdx = 0; %><% fields.forEach((field, idx) => { %><% if (paramIdx > 0) { %>, <% } %><%- field.javaType %> <%= field.name %><% paramIdx++; %><% }); %><% domainRelationships.forEach(rel => { %><% if (!rel.isCollection) { %><% if (paramIdx > 0) { %>, <% } %><%- rel.javaType %> <%= rel.fieldName %><% paramIdx++; %><% } %><% }); %>) {
<% fields.forEach(field => { %>
        this.<%= field.name %> = <%= field.name %>;
<% }); %>
<% domainRelationships.forEach(rel => { %>
  <% if (!rel.isCollection) { %>
        this.<%= rel.fieldName %> = <%= rel.fieldName %>;
  <% } %>
<% }); %>
    }

<% const creationFields = fields.filter(f => f.name !== 'id' && f.name !== 'createdAt' && f.name !== 'updatedAt' && f.name !== 'createdBy' && f.name !== 'updatedBy'); %>
<% if (creationFields.length > 0) { %>
    // Constructor for new entity creation (without id and audit fields)
    public <%= name %>(<% let paramIdx = 0; %><% creationFields.forEach((field, idx) => { %><% if (paramIdx > 0) { %>, <% } %><%- field.javaType %> <%= field.name %><% paramIdx++; %><% }); %>) {
<% creationFields.forEach(field => { %>
        this.<%= field.name %> = <%= field.name %>;
<% }); %>
    }
<% } %>

    // Getters
<% fields.forEach(field => { %>
    public <%- field.javaType %> get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>() {
        return <%= field.name %>;
    }
<% }); %>

<% domainRelationships.forEach(rel => { %>
  <% if (!rel.isCollection) { %>
    public <%- rel.javaType %> get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>() {
        return <%= rel.fieldName %>;
    }
  <% } %>
<% }); %>

    // Business methods for state modification
<% domainRelationships.forEach(rel => { %>
  <% if (!rel.isCollection && rel.type === 'OneToOne' && rel.mappedBy) { %>
    
    /**
     * Assigns <%= rel.fieldName %> to this <%= name %>
     * Maintains bidirectional relationship consistency
     */
    public void assign<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>(<%- rel.javaType %> <%= rel.fieldName %>) {
        this.<%= rel.fieldName %> = <%= rel.fieldName %>;
        if (<%= rel.fieldName %> != null) {
            <%= rel.fieldName %>.assign<%= name %>(this);
        }
    }
  <% } %>
<% }); %>

    // Aggregate business methods (factory methods for creating entities)
<% aggregateMethods.filter(m => !m.isOverload).forEach(method => { %>
    
    /**
     * <%= method.name %>
     <% if (method.isFactory) { %>
     * Creates entity internally and adds it to the aggregate
     * Add your business validation rules here before entity creation
     <% } %>
     */
    public <%- method.returnType %> <%= method.name %>(<% method.parameters.forEach((param, idx) => { %><%- param.type %> <%= param.name %><%= idx < method.parameters.length - 1 ? ', ' : '' %><% }); %>) {
        <%- method.body %>
    }
<% }); %>

    // Overloaded methods (alternative signatures)
<% aggregateMethods.filter(m => m.isOverload).forEach(method => { %>
    
    /**
     * <%= method.name %> - Overload
     <% if (method.isFactory) { %>
     * Creates entity internally and assigns/adds it to the aggregate
     * Add your business validation rules here before entity creation
     <% } else { %>
     * Adds an existing entity (for complex mapping scenarios)
     <% } %>
     */
    public <%- method.returnType %> <%= method.name %>(<% method.parameters.forEach((param, idx) => { %><%- param.type %> <%= param.name %><%= idx < method.parameters.length - 1 ? ', ' : '' %><% }); %>) {
        <%- method.body %>
    }
<% }); %>
}
