package <%= packageName %>.<%= moduleName %>.infrastructure.database.mappers;

import org.springframework.stereotype.Component;
import <%= packageName %>.<%= moduleName %>.domain.models.entities.*;
<% if (valueObjects && valueObjects.length > 0) { %>
import <%= packageName %>.<%= moduleName %>.domain.models.valueObjects.*;
import <%= packageName %>.<%= moduleName %>.infrastructure.database.valueObjects.*;
<% } %>
import <%= packageName %>.<%= moduleName %>.infrastructure.database.entities.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * <%= aggregateName %>Mapper
 * Maps between domain and JPA entities
 */
@Component
public class <%= aggregateName %>Mapper {
    
    // ========== Aggregate Root Mapping ==========
    
    /**
     * Convert JPA entity to domain entity
     */
    public <%= rootEntity.name %> toDomain(<%= rootEntity.name %>Jpa jpa) {
        if (jpa == null) return null;
        
        <%= rootEntity.name %> domain = new <%= rootEntity.name %>(
<% rootEntity.fields.forEach((field, idx) => { %>
  <% if (field.isCollection && field.isValueObject) { %>
            jpa.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>() != null ? jpa.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>().stream().map(this::toDomain<%= field.collectionElementType %>).collect(Collectors.toList()) : new ArrayList<>()<%= idx < rootEntity.fields.length - 1 || rootEntity.relationships.filter(r => !r.isCollection).length > 0 ? ',' : '' %>
  <% } else if (field.isValueObject) { %>
            toDomain<%= field.javaType %>(jpa.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>())<%= idx < rootEntity.fields.length - 1 || rootEntity.relationships.filter(r => !r.isCollection).length > 0 ? ',' : '' %>
  <% } else { %>
            jpa.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>()<%= idx < rootEntity.fields.length - 1 || rootEntity.relationships.filter(r => !r.isCollection).length > 0 ? ',' : '' %>
  <% } %>
<% }); %>
<% rootEntity.relationships.filter(r => !r.isCollection).forEach((rel, idx) => { %>            toDomain<%= rel.target %>(jpa.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>())<%= idx < rootEntity.relationships.filter(r => !r.isCollection).length - 1 ? ',' : '' %>
<% }); %>
        );
        
<% rootEntity.relationships.forEach(rel => { %>
  <% if (rel.isCollection && rel.type === 'OneToMany') { %>
        // Map <%= rel.fieldName %> collection
        if (jpa.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>() != null) {
            jpa.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>().forEach(itemJpa -> {
                domain.add<%= rel.target %>(toDomain<%= rel.target %>(itemJpa));
            });
        }
  <% } %>
<% }); %>
        
        return domain;
    }
    
    /**
     * Convert domain entity to JPA entity
     */
    public <%= rootEntity.name %>Jpa toJpa(<%= rootEntity.name %> domain) {
        if (domain == null) return null;
        
        <%= rootEntity.name %>Jpa jpa = <%= rootEntity.name %>Jpa.builder()
<% rootEntity.fields.filter(f => !(f.name === 'createdAt' || f.name === 'updatedAt' || f.name === 'createdBy' || f.name === 'updatedBy')).forEach(field => { -%>
<% if (field.isCollection && field.isValueObject) { -%>
                .<%= field.name %>(domain.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>() != null ? domain.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>().stream().map(this::toJpa<%= field.collectionElementType %>).collect(Collectors.toList()) : new ArrayList<>())
<% } else if (field.isValueObject) { -%>
                .<%= field.name %>(toJpa<%= field.javaType %>(domain.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>()))
<% } else { -%>
                .<%= field.name %>(domain.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>())
<% } -%>
<% }); -%>
                .build();
        
<% rootEntity.relationships.forEach(rel => { %>
  <% if (rel.isCollection && rel.type === 'OneToMany') { %>
        // Map <%= rel.fieldName %> with bidirectional reference
        List<<%= rel.target %>Jpa> <%= rel.fieldName %>Jpa = domain.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>().stream()
            .map(item -> toJpa<%= rel.target %>(item, jpa))
            .collect(Collectors.toList());
        jpa.set<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>(<%= rel.fieldName %>Jpa);
  <% } else if (!rel.isCollection && rel.type === 'OneToOne') { %>
        // Map OneToOne relationship <%= rel.fieldName %>
        if (domain.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>() != null) {
            <%= rel.target %>Jpa <%= rel.fieldName %>Jpa = toJpa<%= rel.target %>(domain.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>(), jpa);
            jpa.set<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>(<%= rel.fieldName %>Jpa);
        }
  <% } else if (!rel.isCollection) { %>
        jpa.set<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>(toJpa<%= rel.target %>(domain.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>()));
  <% } %>
<% }); %>
        
        return jpa;
    }
    
<% if (secondaryEntities.length > 0) { %>
    // ========== Secondary Entities Mapping ==========
<% secondaryEntities.forEach(entity => { %>
<% const entityFwdOtoRels = entity.relationships.filter(r => r.type === 'OneToOne' && !r.isInverse && r.target !== rootEntity.name); %>
    
    /**
     * Convert <%= entity.name %>Jpa to <%= entity.name %>
     */
    private <%= entity.name %> toDomain<%= entity.name %>(<%= entity.name %>Jpa jpa) {
        if (jpa == null) return null;
<% const entityFwdOtoManyRels = entity.relationships.filter(r => r.isCollection && r.type === 'OneToMany' && !r.isInverse); %>
        
        <%= entity.name %> domain = new <%= entity.name %>(
<% entity.fields.forEach((field, idx) => { %>
  <% if (field.isCollection && field.isValueObject) { %>
            jpa.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>() != null ? jpa.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>().stream().map(this::toDomain<%= field.collectionElementType %>).collect(Collectors.toList()) : new ArrayList<>()<%= idx < entity.fields.length - 1 || entityFwdOtoRels.length > 0 ? ',' : '' %>
  <% } else if (field.isValueObject) { %>
            toDomain<%= field.javaType %>(jpa.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>())<%= idx < entity.fields.length - 1 || entityFwdOtoRels.length > 0 ? ',' : '' %>
  <% } else { %>
            jpa.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>()<%= idx < entity.fields.length - 1 || entityFwdOtoRels.length > 0 ? ',' : '' %>
  <% } %>
<% }); %>
<% entityFwdOtoRels.forEach((rel, idx) => { %>
            toDomain<%= rel.target %>(jpa.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>())<%= idx < entityFwdOtoRels.length - 1 ? ',' : '' %>
<% }); %>
        );
<% entityFwdOtoManyRels.forEach(rel => { %>
        
        // Map <%= rel.fieldName %> nested collection
        if (jpa.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>() != null) {
            jpa.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>().forEach(itemJpa -> {
                domain.add<%= rel.target %>(toDomain<%= rel.target %>(itemJpa));
            });
        }
<% }); %>
        
        return domain;
    }
    
    /**
     * Convert <%= entity.name %> to <%= entity.name %>Jpa
     */
<% const parentRel = entity.relationships && entity.relationships.find(r => r.isInverse && r.type === 'ManyToOne'); %>
    private <%= entity.name %>Jpa toJpa<%= entity.name %>(<%= entity.name %> domain<%= parentRel ? ', ' + parentRel.target + 'Jpa parentJpa' : '' %>) {
        if (domain == null) return null;
        
        <%= entity.name %>Jpa entityJpa = <%= entity.name %>Jpa.builder()
<% entity.fields.filter(f => !(f.name === 'createdAt' || f.name === 'updatedAt' || f.name === 'createdBy' || f.name === 'updatedBy')).forEach(field => { -%>
<% if (field.isCollection && field.isValueObject) { -%>
                .<%= field.name %>(domain.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>() != null ? domain.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>().stream().map(this::toJpa<%= field.collectionElementType %>).collect(Collectors.toList()) : new ArrayList<>())
<% } else if (field.isValueObject) { -%>
                .<%= field.name %>(toJpa<%= field.javaType %>(domain.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>()))
<% } else { -%>
                .<%= field.name %>(domain.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>())
<% } -%>
<% }); -%>
<% entity.relationships.forEach(rel => { -%>
<% if (rel.type === 'ManyToOne' || rel.type === 'OneToOne') { -%>
<% if (rel.isInverse && parentRel && rel.fieldName === parentRel.fieldName) { -%>
                .<%= rel.fieldName %>(parentJpa)
<% } else if (rel.isInverse) { -%>
                // <%= rel.fieldName %> - inverse relationship, set by owning side
<% } else if (rel.type === 'OneToOne') { -%>
                // <%= rel.fieldName %> - forward OneToOne, set via post-build (requires back-reference)
<% } else { -%>
                .<%= rel.fieldName %>(toJpa<%= rel.target %>(domain.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>()))
<% } -%>
<% } -%>
<% }); -%>
                .build();
<% entityFwdOtoRels.forEach(rel => { %>
        
        // Set forward OneToOne <%= rel.fieldName %> with back-reference FK
        if (domain.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>() != null) {
            <%= rel.target %>Jpa <%= rel.fieldName %>Jpa = toJpa<%= rel.target %>(domain.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>());
            if (<%= rel.fieldName %>Jpa != null) {
                <%= rel.fieldName %>Jpa.set<%= entity.name %>(entityJpa);
                entityJpa.set<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>(<%= rel.fieldName %>Jpa);
            }
        }
<% }); %>
<% (entity.relationships || []).filter(r => r.isCollection && r.type === 'OneToMany' && !r.isInverse).forEach(rel => { %>
        
        // Map <%= rel.fieldName %> nested collection with parent back-reference
        if (domain.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>() != null) {
            List<<%= rel.target %>Jpa> <%= rel.fieldName %>Jpa = domain.get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>().stream()
                .map(item -> toJpa<%= rel.target %>(item, entityJpa))
                .collect(Collectors.toList());
            entityJpa.set<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>(<%= rel.fieldName %>Jpa);
        }
<% }); %>
        return entityJpa;
    }
<% }); %>
<% } %>
    
<% if (valueObjects.length > 0) { %>
    // ========== Value Objects Mapping ==========
<% valueObjects.forEach(vo => { %>
    
    /**
     * Convert <%= vo.name %>Jpa to <%= vo.name %>
     */
    private <%= vo.name %> toDomain<%= vo.name %>(<%= vo.name %>Jpa jpa) {
        if (jpa == null) return null;
        
        return new <%= vo.name %>(
<% vo.fields.forEach((field, idx) => { %>
            jpa.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>()<%= idx < vo.fields.length - 1 ? ',' : '' %>
<% }); %>
        );
    }
    
    /**
     * Convert <%= vo.name %> to <%= vo.name %>Jpa
     */
    private <%= vo.name %>Jpa toJpa<%= vo.name %>(<%= vo.name %> domain) {
        if (domain == null) return null;
        
        return new <%= vo.name %>Jpa(
<% vo.fields.forEach((field, idx) => { %>
            domain.get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>()<%= idx < vo.fields.length - 1 ? ',' : '' %>
<% }); %>
        );
    }
<% }); %>
<% } %>
}
