package <%= packageName %>.<%= moduleName %>.domain.models.entities;

<% imports.forEach(imp => { %>
<%- imp %>
<% }); %>
<% if (valueObjects && valueObjects.length > 0) { %>
import <%= packageName %>.<%= moduleName %>.domain.models.valueObjects.*;
<% } %>
<% if (fields.some(f => f.transitionMeta)) { %>
import <%= packageName %>.<%= moduleName %>.domain.models.enums.*;
<% } %>
<% if (fields.some(f => f.transitionMeta && f.transitionMeta.transitions.some(t => t.guard))) { %>
import <%= packageName %>.shared.domain.customExceptions.BusinessException;
<% } %>
<% const forwardOneToManyRels = relationships.filter(rel => !rel.isInverse && rel.type === 'OneToMany'); %>
<% if (forwardOneToManyRels.length > 0) { %>
import java.util.Collections;
<% } %>

/**
 * <%= name %> - Domain Entity
 * Secondary entity in aggregate (pure Java class without Lombok)
 */
public class <%= name %> {
    
<% fields.forEach(field => { %>
  <% if (field.isCollection) { %>
    private <%- field.javaType %> <%= field.name %> = new ArrayList<>();
  <% } else { %>
    private <%- field.javaType %> <%= field.name %>;
  <% } %>
<% }); %>

<% relationships.forEach(rel => { %>
  <% if (rel.isCollection) { %>
    private <%- rel.javaType %> <%= rel.fieldName %> = new ArrayList<>();
  <% } else { %>
    private <%- rel.javaType %> <%= rel.fieldName %>;
  <% } %>
<% }); %>

    // Full constructor (for reconstruction from persistence)
    public <%= name %>(<% let paramIdx = 0; %><% fields.forEach((field, idx) => { %><% if (paramIdx > 0) { %>, <% } %><%- field.javaType %> <%= field.name %><% paramIdx++; %><% }); %><% const nonInverseRels = relationships.filter(rel => !rel.isInverse && !rel.isCollection); %><% nonInverseRels.forEach(rel => { %><% if (paramIdx > 0) { %>, <% } %><%- rel.javaType %> <%= rel.fieldName %><% paramIdx++; %><% }); %>) {
<% fields.forEach(field => { %>
        this.<%= field.name %> = <%= field.name %>;
<% }); %>
<% nonInverseRels.forEach(rel => { %>
        this.<%= rel.fieldName %> = <%= rel.fieldName %>;
<% }); %>
    }

<% const creationFields = fields.filter(f => f.name !== 'id' && f.name !== 'createdAt' && f.name !== 'updatedAt' && f.name !== 'createdBy' && f.name !== 'updatedBy' && !f.readOnly && !f.autoInit); %>
<% const autoInitFields = fields.filter(f => f.autoInit); %>
<% if (creationFields.length > 0 || autoInitFields.length > 0) { %>
    // Constructor for new entity creation (without id, audit fields, readOnly and auto-initialized fields)
    public <%= name %>(<% let paramIdx = 0; %><% creationFields.forEach((field, idx) => { %><% if (paramIdx > 0) { %>, <% } %><%- field.javaType %> <%= field.name %><% paramIdx++; %><% }); %>) {
<% creationFields.forEach(field => { %>
        this.<%= field.name %> = <%= field.name %>;
<% }); %>
<% autoInitFields.forEach(field => { %>
        this.<%= field.name %> = <%- field.javaType %>.<%= field.autoInitValue %>;
<% }); %>
    }
<% } %>

    // Getters
<% fields.forEach(field => { %>
    public <%- field.javaType %> get<%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %>() {
        return <%= field.name %>;
    }
<% }); %>

<% relationships.forEach(rel => { %>
  <% if (!rel.isInverse && rel.type === 'OneToMany') { %>
    public <%- rel.javaType %> get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>() {
        return Collections.unmodifiableList(<%= rel.fieldName %>);
    }
  <% } else { %>
    public <%- rel.javaType %> get<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>() {
        return <%= rel.fieldName %>;
    }
  <% } %>
<% }); %>

    // Business methods for inverse relationships (package-private for aggregate control)
<% relationships.forEach(rel => { %>
  <% if (rel.isInverse) { %>
    
    /**
     * Assigns <%= rel.fieldName %> (inverse relationship)
     * Called by aggregate root to maintain bidirectional consistency
     */
    void assign<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>(<%- rel.javaType %> <%= rel.fieldName %>) {
        this.<%= rel.fieldName %> = <%= rel.fieldName %>;
    }
  <% } %>
<% }); %>
<% const forwardOneToOneRels = relationships.filter(rel => !rel.isInverse && rel.type === 'OneToOne'); %>
<% if (forwardOneToOneRels.length > 0) { %>
    // Business methods for forward OneToOne relationships
<% forwardOneToOneRels.forEach(rel => { %>

    /**
     * Assigns <%= rel.fieldName %>
     */
    public void assign<%= rel.fieldName.charAt(0).toUpperCase() + rel.fieldName.slice(1) %>(<%- rel.javaType %> <%= rel.fieldName %>) {
        this.<%= rel.fieldName %> = <%= rel.fieldName %>;
    }
<% }); %>
<% } %>
<% if (forwardOneToManyRels.length > 0) { %>
    // Business methods for forward OneToMany relationships
<% forwardOneToManyRels.forEach(rel => { %>

    /**
     * Adds a <%= rel.target %> to this entity
     */
    public void add<%= rel.target %>(<%= rel.target %> item) {
        if (item != null) {
            this.<%= rel.fieldName %>.add(item);
        }
    }

    /**
     * Removes a <%= rel.target %> from this entity
     */
    public void remove<%= rel.target %>(<%= rel.target %> item) {
        this.<%= rel.fieldName %>.remove(item);
    }
<% }); %>
<% } %>
<% const transitionFields = fields.filter(f => f.transitionMeta); %>
<% if (transitionFields.length > 0) { %>

    // ─── State Transition Methods ────────────────────────────────────────────────
<% transitionFields.forEach(field => { %>
<%     const meta = field.transitionMeta; %>
<%     const methodMap = new Map(); %>
<%     meta.transitions.forEach(t => { if (t.method && !methodMap.has(t.method)) methodMap.set(t.method, t); }); %>
<%     methodMap.forEach((transition, methodName) => { %>
<%         const froms = Array.isArray(transition.from) ? transition.from : [transition.from]; %>

    /**
     * Transitions [<%= field.name %>] from [<%= froms.join(', ') %>] to <%= transition.to %>
     */
    public void <%= methodName %>() {
<% if (transition.guard) { %>
        if (<%= transition.guard %>) {
            throw new BusinessException("Cannot execute '<%= methodName %>': business rule violated");
        }
<% } %>
        this.<%= field.name %> = this.<%= field.name %>.transitionTo(<%- field.javaType %>.<%= transition.to %>);
    }
<%     }); %>

    // ─── State Query Helpers ─────────────────────────────────────────────────────
<%     meta.enumValues.forEach(value => { %>
    public boolean is<%= value.charAt(0) + value.slice(1).toLowerCase() %>() {
        return this.<%= field.name %> == <%- field.javaType %>.<%= value %>;
    }
<%     }); %>

    // ─── Transition Readiness Helpers ────────────────────────────────────────────
<%     methodMap.forEach((transition, methodName) => { %>
    public boolean can<%= methodName.charAt(0).toUpperCase() + methodName.slice(1) %>() {
        return this.<%= field.name %>.canTransitionTo(<%- field.javaType %>.<%= transition.to %>);
    }
<%     }); %>
<% }); %>
<% } %>
}
