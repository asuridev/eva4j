package <%= packageName %>.<%= moduleName %>.application.usecases;

import <%= packageName %>.shared.domain.annotations.ApplicationComponent;
import org.springframework.transaction.event.TransactionPhase;
import org.springframework.transaction.event.TransactionalEventListener;
<% domainEvents.forEach(event => { %>
import <%= packageName %>.<%= moduleName %>.domain.models.events.<%= event.name %>;
<% }); %>
<% if (hasKafkaEvents) { %>
import <%= packageName %>.<%= moduleName %>.domain.repositories.MessageBroker;
<% } %>

/**
 * <%= aggregateName %>DomainEventHandler — Domain Event Bridge
 *
 * This handler connects the internal Spring event bus (ApplicationEventPublisher)
 * with the external messaging port (MessageBroker).
 *
 * Architecture:
 *   AggregateRepositoryImpl.save()
 *     → eventPublisher.publishEvent(domainEvent)   [internal Spring bus]
 *       → @TransactionalEventListener(AFTER_COMMIT) [this class]
 *         → messageBroker.send*(event)             [port — broker-agnostic]
 *
 * AFTER_COMMIT ensures the external event is only published if the
 * database transaction committed successfully, preventing ghost events
 * from rolled-back operations.
 *
 * To switch brokers (Kafka → RabbitMQ → SNS): change only the MessageBroker
 * adapter in infrastructure/. This class never needs modification.
 */
@ApplicationComponent
public class <%= aggregateName %>DomainEventHandler {
<% if (hasKafkaEvents) { %>

    private final MessageBroker messageBroker;

    public <%= aggregateName %>DomainEventHandler(MessageBroker messageBroker) {
        this.messageBroker = messageBroker;
    }
<% } %>
<% domainEvents.forEach(event => { %>

    /**
     * Handles {@link <%= event.name %>} after the wrapping transaction commits.
     * <% if (!event.kafka) { %>
     * TODO: Implement the side effect for this event (e.g., send notification,
     *       update a read model, trigger a saga step, etc.).
     * <% } %>
     */
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void on<%= event.name %>(<%=  event.name %> event) {
    <% if (event.kafka) { %>
        messageBroker.send<%= event.name %>(event);
    <% } else { %>
        // TODO: handle <%= event.name %> — add your side-effect logic here
        //   e.g.:  notificationService.notify(event);
        //          readModelUpdater.on(event);
    <% } %>
    }
<% }); %>
}
