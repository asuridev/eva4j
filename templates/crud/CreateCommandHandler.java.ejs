package <%= packageName %>.<%= moduleName %>.application.usecases;

import <%= packageName %>.<%= moduleName %>.application.commands.Create<%= aggregateName %>Command;
import <%= packageName %>.<%= moduleName %>.domain.models.entities.<%= aggregateName %>;
import <%= packageName %>.<%= moduleName %>.domain.repositories.<%= aggregateName %>Repository;
import <%= packageName %>.<%= moduleName %>.application.mappers.<%= aggregateName %>ApplicationMapper;
import <%= packageName %>.shared.domain.annotations.ApplicationComponent;
import <%= packageName %>.shared.domain.interfaces.CommandHandler;
import lombok.extern.slf4j.Slf4j;
import org.springframework.transaction.annotation.Transactional;

/**
 * Create<%= aggregateName %>CommandHandler
 * Handles the creation of a new <%= aggregateName %> aggregate
 */
@Slf4j
@ApplicationComponent
public class Create<%= aggregateName %>CommandHandler implements CommandHandler<Create<%= aggregateName %>Command> {

    private final <%= aggregateName %>Repository repository;
    private final <%= aggregateName %>ApplicationMapper mapper;

    public Create<%= aggregateName %>CommandHandler(<%= aggregateName %>Repository repository, <%= aggregateName %>ApplicationMapper mapper) {
        this.repository = repository;
        this.mapper = mapper;
    }

    @Override
    @Transactional
    public void handle(Create<%= aggregateName %>Command command) {
        log.info("Handling Create<%= aggregateName %>Command: {}", command);
        
        // Create root entity with main fields only
        <%= aggregateName %> entity = new <%= aggregateName %>(
<% if (commandFields) { %>
<% commandFields.forEach((field, idx) => { %>
            <% if (field.originalVoType) { %>mapper.to<%= field.originalVoType %>(command.<%= field.name %>())<% } else { %>command.<%= field.name %>()<% } %><%= idx < commandFields.length - 1 ? ',' : '' %>
<% }); %>
<% } %>
        );
        
<% if (oneToManyRelationships && oneToManyRelationships.length > 0) { %>
<% oneToManyRelationships.forEach(rel => { %>
        // Add <%= rel.fieldName %> using aggregate method (executes business validations)
        if (command.<%= rel.fieldName %>() != null) {
            command.<%= rel.fieldName %>().forEach(itemDto -> {
  <% if (!rel.hasNestedRelationships && !(rel.nestedOneToOneRelationships && rel.nestedOneToOneRelationships.length > 0)) { %>
                entity.add<%= rel.targetEntityName %>(
<% rel.fields.forEach((field, idx) => { %>
                    <% if (field.originalVoType) { %>mapper.to<%= field.originalVoType %>(itemDto.<%= field.name %>())<% } else { %>itemDto.<%= field.name %>()<% } %><%= idx < rel.fields.length - 1 ? ',' : '' %>
<% }); %>
                );
  <% } else if (!rel.hasNestedRelationships && rel.nestedOneToOneRelationships && rel.nestedOneToOneRelationships.length > 0) { %>
                // Flattened factory call (DDD: aggregate root controls all sub-entity creation)
                entity.add<%= rel.targetEntityName %>(
<% rel.fields.forEach(field => { %>
                    <% if (field.originalVoType) { %>mapper.to<%= field.originalVoType %>(itemDto.<%= field.name %>())<% } else { %>itemDto.<%= field.name %>()<% } %>,
<% }); %>
<% rel.nestedOneToOneRelationships.forEach((otoRel, otoIdx) => { %>
<% otoRel.fields.forEach((field, fIdx) => { %>
<% const isLastParam = otoIdx === rel.nestedOneToOneRelationships.length - 1 && fIdx === otoRel.fields.length - 1; %>
                    itemDto.<%= otoRel.fieldName %>() != null ? <% if (field.originalVoType) { %>mapper.to<%= field.originalVoType %>(itemDto.<%= otoRel.fieldName %>().<%= field.name %>())<% } else { %>itemDto.<%= otoRel.fieldName %>().<%= field.name %>()<% } %> : null<%= isLastParam ? '' : ',' %>
<% }); %>
<% }); %>
                );
  <% } else { %>
                // Complex nested collections â€” use mapper helper
                entity.add<%= rel.targetEntityName %>(mapper.fromDto<%= rel.targetEntityName %>(itemDto));
  <% } %>
            });
        }
        
<% }); %>
<% } %>
<% if (oneToOneRelationships && oneToOneRelationships.length > 0) { %>
<% oneToOneRelationships.forEach(rel => { %>
        // Assign <%= rel.fieldName %> using aggregate method (executes business validations)
        if (command.<%= rel.fieldName %>() != null) {
            entity.assign<%= rel.targetEntityName %>(
<% rel.fields.forEach((field, idx) => { %>
                <% if (field.originalVoType) { %>mapper.to<%= field.originalVoType %>(command.<%= rel.fieldName %>().<%= field.name %>())<% } else { %>command.<%= rel.fieldName %>().<%= field.name %>()<% } %><%= idx < rel.fields.length - 1 ? ',' : '' %>
<% }); %>
            );
        }
        
<% }); %>
<% } %>
        // Persist aggregate
        <%= aggregateName %> saved = repository.save(entity);
        log.info("<%= aggregateName %> created successfully with id: {}", saved.getId());
    }
}
