# GuÃ­a para Agentes de IA - <%= artifactId %>

## ğŸ“‹ PropÃ³sito del Documento

Este documento proporciona informaciÃ³n clara sobre la arquitectura, patrones y mejores prÃ¡cticas de **eva4j** para que agentes de IA puedan:
- âœ… Comprender la arquitectura hexagonal y DDD implementada
- âœ… Generar cÃ³digo consistente con los patrones establecidos
- âœ… Realizar modificaciones que respeten las convenciones
- âœ… Utilizar correctamente las caracterÃ­sticas de auditorÃ­a y domain modeling

---

## ğŸ—ï¸ Arquitectura General

### Estructura de Capas

eva4j genera proyectos Spring Boot siguiendo **arquitectura hexagonal (puertos y adaptadores)** con **DDD**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    INFRASTRUCTURE LAYER                      â”‚
â”‚  (REST Controllers, JPA Entities, External Adapters)         â”‚
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚            APPLICATION LAYER                       â”‚    â”‚
â”‚  â”‚  (Commands, Queries, Use Cases, DTOs, Mappers)     â”‚    â”‚
â”‚  â”‚                                                     â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚    â”‚
â”‚  â”‚  â”‚         DOMAIN LAYER                     â”‚     â”‚    â”‚
â”‚  â”‚  â”‚  (Entities, Value Objects, Repositories) â”‚     â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Layer Responsibilities

**Domain Layer** (Pure Java, framework-agnostic):
- Business entities and value objects
- Domain logic and invariants
- Repository interfaces (ports)
- Domain services

**Application Layer** (Orchestration):
- Use cases (command and query handlers)
- Commands and Queries (CQRS)
- DTOs for data transfer
- Mappers between layers
- Application services

**Infrastructure Layer** (Technical details):
- JPA entities with Lombok
- Spring Data repositories
- REST controllers
- External API clients
- Event publishers/consumers
- Database adapters

---

## Project Structure

```
<%= artifactId %>/
â”œâ”€â”€ .eva4j.json                    # Project metadata & module registry
â”œâ”€â”€ AGENTS.md                      # This file
â”œâ”€â”€ README.md                      # Project documentation
â”œâ”€â”€ build.gradle                   # Gradle build configuration
â”œâ”€â”€ settings.gradle
â””â”€â”€ src/
    â”œâ”€â”€ main/
    â”‚   â”œâ”€â”€ java/<%= packageName.replace(/\./g, '/') %>/
    â”‚   â”‚   â”œâ”€â”€ <%= applicationClassName %>.java  # Spring Boot entry point
    â”‚   â”‚   â”œâ”€â”€ common/            # Infrastructure (config, exceptions, security)
    â”‚   â”‚   â”œâ”€â”€ shared/            # Cross-cutting domain (base entities, events)
    â”‚   â”‚   â””â”€â”€ [modules]/         # Business modules (after `eva4j add module`)
    â”‚   â”‚       â””â”€â”€ user/          # Example module
    â”‚   â”‚           â”œâ”€â”€ domain/
    â”‚   â”‚           â”‚   â”œâ”€â”€ models/
    â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ entities/        # Pure Java domain entities
    â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ valueObjects/    # Immutable value objects
    â”‚   â”‚           â”‚   â”‚   â””â”€â”€ enums/           # Enumerations
    â”‚   â”‚           â”‚   â”œâ”€â”€ repositories/        # Repository interfaces
    â”‚   â”‚           â”‚   â””â”€â”€ services/            # Domain services
    â”‚   â”‚           â”œâ”€â”€ application/
    â”‚   â”‚           â”‚   â”œâ”€â”€ commands/            # Write operations
    â”‚   â”‚           â”‚   â”œâ”€â”€ queries/             # Read operations
    â”‚   â”‚           â”‚   â”œâ”€â”€ usecases/            # Command/Query handlers
    â”‚   â”‚           â”‚   â”œâ”€â”€ dtos/                # Data Transfer Objects
    â”‚   â”‚           â”‚   â”œâ”€â”€ mappers/             # Layer-to-layer mapping
    â”‚   â”‚           â”‚   â”œâ”€â”€ events/              # Domain events
    â”‚   â”‚           â”‚   â””â”€â”€ ports/               # Output ports (interfaces)
    â”‚   â”‚           â”œâ”€â”€ infrastructure/
    â”‚   â”‚           â”‚   â”œâ”€â”€ database/
    â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ entities/        # JPA entities (Lombok)
    â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ repositories/    # JPA implementations
    â”‚   â”‚           â”‚   â”‚   â””â”€â”€ mappers/         # Domain â†” JPA mapping
    â”‚   â”‚           â”‚   â”œâ”€â”€ rest/
    â”‚   â”‚           â”‚   â”‚   â””â”€â”€ controllers/     # REST endpoints
    â”‚   â”‚           â”‚   â”œâ”€â”€ kafkaListener/       # Event consumers
    â”‚   â”‚           â”‚   â””â”€â”€ adapters/            # External API clients
    â”‚   â”‚           â”œâ”€â”€ package-info.java        # Spring Modulith module marker
    â”‚   â”‚           â””â”€â”€ domain.yaml              # â­ DOMAIN MODEL DEFINITION
    â”‚   â””â”€â”€ resources/
    â”‚       â”œâ”€â”€ application.yaml                 # Main configuration
    â”‚       â”œâ”€â”€ application-{env}.yaml           # Environment-specific configs
    â”‚       â””â”€â”€ parameters/
    â”‚           â””â”€â”€ {env}/
    â”‚               â”œâ”€â”€ db.yaml                  # Database settings
    â”‚               â”œâ”€â”€ cors.yaml                # CORS configuration
    â”‚               â”œâ”€â”€ kafka.yaml               # Kafka topics (if added)
    â”‚               â””â”€â”€ urls.yaml                # External API URLs (if added)
    â””â”€â”€ test/
        â””â”€â”€ java/<%= packageName.replace(/\./g, '/') %>/
            â””â”€â”€ [module]/
```

### Module Organization

Each module (e.g., `user`, `order`, `product`) is:
- **Self-contained**: Own domain, application, and infrastructure layers
- **Independent**: Can be extracted to microservice with `eva4j detach`
- **Bounded Context**: Represents a business capability
- **Spring Modulith Module**: Boundaries enforced at runtime

---

## ğŸ¯ Principios DDD Implementados

### Entidades de Dominio

Las entidades de dominio generadas por eva4j siguen principios estrictos de Domain-Driven Design:

#### âœ… Constructores Obligatorios (SIN Constructor VacÃ­o)

```java
public class User {
    private String id;
    private String username;
    private String email;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // âœ… Constructor completo (para reconstrucciÃ³n desde persistencia)
    public User(String id, String username, String email, 
                LocalDateTime createdAt, LocalDateTime updatedAt) {
        this.id = id;
        this.username = username;
        this.email = email;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }
    
    // âœ… Constructor de creaciÃ³n (sin id, sin audit fields)
    public User(String username, String email) {
        this.username = username;
        this.email = email;
    }
    
    // âŒ NO HAY constructor vacÃ­o - Evita estados invÃ¡lidos
}
```

**RazÃ³n:** El constructor vacÃ­o permite crear entidades en estado invÃ¡lido, violando invariantes de dominio.

#### âŒ Sin Setters PÃºblicos

```java
// âŒ NO HACER - Setters pÃºblicos
public void setEmail(String email) {
    this.email = email;
}

// âœ… SÃ HACER - MÃ©todos de negocio
public void updateEmail(String newEmail) {
    if (newEmail == null || !newEmail.contains("@")) {
        throw new IllegalArgumentException("Invalid email format");
    }
    this.email = newEmail;
}
```

#### âœ… Getters PÃºblicos

```java
// âœ… Getters siempre pÃºblicos
public String getUsername() {
    return username;
}

public String getEmail() {
    return email;
}
```

#### âœ… MÃ©todos de Negocio para Modificar Estado

```java
public class Order {
    private OrderStatus status;
    
    // âœ… MÃ©todos de negocio con validaciones
    public void confirm() {
        if (this.status == OrderStatus.CANCELLED) {
            throw new IllegalStateException("Cannot confirm cancelled order");
        }
        this.status = OrderStatus.CONFIRMED;
    }
    
    public void cancel() {
        if (this.status == OrderStatus.DELIVERED) {
            throw new IllegalStateException("Cannot cancel delivered order");
        }
        this.status = OrderStatus.CANCELLED;
    }
}
```

### Entidades JPA (Infraestructura)

Las entidades JPA **SÃ usan Lombok** y tienen caracterÃ­sticas diferentes:

```java
@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor  // âœ… Requerido por JPA
@AllArgsConstructor
@Builder
public class UserJpa extends AuditableEntity {
    
    @Id
    private String id;
    
    @Column(name = "username")
    private String username;
    
    @Column(name = "email")
    private String email;
    
    // Hereda campos de auditorÃ­a
}
```

**CaracterÃ­sticas JPA:**
- âœ… Usa `@Getter`, `@Setter`, `@Builder` de Lombok
- âœ… SÃ tiene constructor vacÃ­o (requerido por JPA)
- âœ… Extiende clases base de auditorÃ­a
- âœ… Solo vive en capa de infraestructura

---

## domain.yaml - The Heart of Code Generation

**Location**: `src/main/java/<%= packageName.replace(/\./g, '/') %>/[module]/domain.yaml`

The `domain.yaml` file is the **single source of truth** for your domain model. It drives code generation for:
- Domain entities (pure Java)
- JPA entities (with Lombok, @Entity, @Table)
- Repository interfaces and implementations
- Mappers (bidirectional domain â†” JPA)
- CRUD operations (when using `eva4j g resource`)

### Basic Structure

```yaml
aggregates:
  - name: Order                    # Aggregate root name (PascalCase)
    entities:
      - name: order                # Entity name (camelCase or snake_case)
        isRoot: true               # âš ï¸ ONE entity MUST have isRoot: true
        tableName: orders          # Optional, defaults to snake_case plural
        auditable: true            # Adds createdAt/updatedAt fields
        fields:
          - name: id
            type: String           # String â†’ UUID, Long â†’ IDENTITY
          - name: customerId
            type: String
          - name: status
            type: OrderStatus      # Reference to enum below
          - name: totalAmount
            type: Money            # Reference to value object below
          - name: orderDate
            type: LocalDateTime
        relationships:
          - type: OneToMany
            target: OrderItem      # Secondary entity
            mappedBy: order        # Field in OrderItem
            cascade: [PERSIST, MERGE, REMOVE]
            fetch: LAZY
      
      - name: orderItem            # Secondary entity (no isRoot)
        tableName: order_items
        fields:
          - name: id
            type: Long
          - name: productId
            type: String
          - name: quantity
            type: Integer
          - name: unitPrice
            type: BigDecimal
    
    valueObjects:                  # Embedded objects (@Embeddable)
      - name: Money
        fields:
          - name: amount
            type: BigDecimal
          - name: currency
            type: String
    
    enums:                         # Enumerations
      - name: OrderStatus
        values:
          - DRAFT
          - CONFIRMED
          - SHIPPED
          - DELIVERED
          - CANCELLED
```

### Supported Field Types

| YAML Type        | Java Type        | Notes                          |
|------------------|------------------|--------------------------------|
| `String`         | `String`         | UUID when used as ID           |
| `Long`           | `Long`           | IDENTITY when used as ID       |
| `Integer`        | `Integer`        |                                |
| `Double`         | `Double`         |                                |
| `BigDecimal`     | `BigDecimal`     | For monetary values            |
| `Boolean`        | `Boolean`        |                                |
| `LocalDate`      | `LocalDate`      | Date without time              |
| `LocalDateTime`  | `LocalDateTime`  | Date with time                 |
| `List<Type>`     | `List<Type>`     | Collections                    |
| `EnumName`       | `EnumName`       | Reference to enum in aggregate |
| `ValueObjName`   | `ValueObjName`   | Reference to value object      |

### Relationships

> **âš ï¸ IMPORTANT**: eva4j **automatically generates inverse relationships**. For bidirectional relationships (OneToMany, OneToOne), you only need to define the relationship **on the parent side** with `mappedBy`. The inverse relationship (ManyToOne) is automatically created. You do NOT need to define both directions manually.

**OneToMany (Parent â†’ Children)** - Bidirectional:
```yaml
# âœ… ONLY define this in the parent entity (Order)
relationships:
  - type: OneToMany
    target: OrderItem              # Child entity
    mappedBy: order                # Field in child that references parent
    cascade: [PERSIST, MERGE, REMOVE]
    fetch: LAZY                    # LAZY or EAGER

# âœ… eva4j automatically generates ManyToOne in OrderItem
# You DON'T need to add this in orderItem entity:
# relationships:
#   - type: ManyToOne
#     target: Order
#     joinColumn: order_id
```

**ManyToOne (Child â†’ Parent)** - Unidirectional:
```yaml
# Only use this if you need ONLY child â†’ parent navigation
# (no parent â†’ children collection)
relationships:
  - type: ManyToOne
    target: Order                  # Parent entity
    joinColumn: order_id           # FK column name
    fetch: EAGER
```

**OneToOne** - Bidirectional:
```yaml
# âœ… ONLY define this in the owning entity (User)
relationships:
  - type: OneToOne
    target: UserProfile
    mappedBy: user                 # Field in UserProfile
    cascade: [PERSIST, MERGE, REMOVE]
    fetch: LAZY

# âœ… eva4j automatically generates the inverse ManyToOne in UserProfile
# You DON'T need to add this in userProfile entity:
# relationships:
#   - type: ManyToOne
#     target: User
#     joinColumn: user_id
```

### Auditable Entities

**Nueva sintaxis mejorada:**

```yaml
entities:
  - name: user
    isRoot: true
    tableName: users
    audit:
      enabled: true      # âœ… Agrega createdAt, updatedAt
      trackUser: true    # âœ… Agrega createdBy, updatedBy
    fields:
      - name: id
        type: String
      - name: username
        type: String
      # createdAt, updatedAt, createdBy, updatedBy se agregan automÃ¡ticamente
```

#### Campos Generados AutomÃ¡ticamente

**Solo con `audit.enabled: true`:**

```java
// En entidad de dominio y JPA
private LocalDateTime createdAt;
private LocalDateTime updatedAt;
```

**Con `audit.trackUser: true`:**

```java
// En entidad de dominio y JPA
private LocalDateTime createdAt;
private LocalDateTime updatedAt;
private String createdBy;    // â† Usuario que creÃ³
private String updatedBy;    // â† Usuario que modificÃ³
```

#### Herencia JPA SegÃºn AuditorÃ­a

```java
// SIN auditorÃ­a
public class UserJpa {
    @Id
    private String id;
    // ... campos
}

// CON audit.enabled: true
public class UserJpa extends AuditableEntity {
    @Id
    private String id;
    // Hereda: createdAt, updatedAt
}

// CON audit.trackUser: true
public class UserJpa extends FullAuditableEntity {
    @Id
    private String id;
    // Hereda: createdAt, updatedAt, createdBy, updatedBy
}
```

#### Infraestructura de AuditorÃ­a de Usuario

Cuando `trackUser: true`, eva4j genera automÃ¡ticamente:

**1. UserContextFilter** - Captura header `X-User`:
```java
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class UserContextFilter extends OncePerRequestFilter {
    private static final String USER_HEADER = "X-User";
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                    HttpServletResponse response, 
                                    FilterChain filterChain) {
        String username = request.getHeader(USER_HEADER);
        if (username != null && !username.isEmpty()) {
            UserContextHolder.setCurrentUser(username);
        }
        try {
            filterChain.doFilter(request, response);
        } finally {
            UserContextHolder.clear();
        }
    }
}
```

**2. UserContextHolder** - ThreadLocal para username:
```java
public class UserContextHolder {
    private static final ThreadLocal<String> currentUser = new ThreadLocal<>();
    
    public static void setCurrentUser(String username) {
        currentUser.set(username);
    }
    
    public static String getCurrentUser() {
        return currentUser.get();
    }
    
    public static void clear() {
        currentUser.remove();
    }
}
```

**3. AuditorAwareImpl** - Proveedor para JPA Auditing:
```java
@Component("auditorProvider")
public class AuditorAwareImpl implements AuditorAware<String> {
    
    @Override
    public Optional<String> getCurrentAuditor() {
        String username = UserContextHolder.getCurrentUser();
        return Optional.ofNullable(username != null ? username : "system");
    }
}
```

**4. ConfiguraciÃ³n en Application.java**:
```java
@EnableJpaAuditing(auditorAwareRef = "auditorProvider")
public class <%= applicationClassName %> {
    // ...
}
```

#### DTOs de Respuesta - ExclusiÃ³n de Campos de Usuario

Los campos `createdBy` y `updatedBy` **NO se exponen en DTOs de respuesta**:

```java
// ResponseDto generado
public record UserResponseDto(
    String id,
    String username,
    String email,
    LocalDateTime createdAt,    // âœ… SÃ se expone
    LocalDateTime updatedAt     // âœ… SÃ se expone
    // createdBy y updatedBy NO se exponen (informaciÃ³n administrativa)
) {}
```

**RazÃ³n:** `createdBy` y `updatedBy` son metadatos administrativos que no deben exponerse en APIs pÃºblicas.

---

## Generated Code Mapping

### From domain.yaml to Code

For aggregate `Order` with entity `order` (isRoot: true):

#### 1. Domain Entity (Pure Java)
**File**: `domain/models/entities/Order.java`
```java
package <%= packageName %>.order.domain.models.entities;

public class Order {
    private String id;
    private String customerId;
    private OrderStatus status;
    private Money totalAmount;
    private LocalDateTime orderDate;
    private List<OrderItem> items;
    
    // Constructor, getters, setters, business logic
}
```

#### 2. JPA Entity (Lombok)
**File**: `infrastructure/database/entities/OrderJpa.java`
```java
package <%= packageName %>.order.infrastructure.database.entities;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "orders")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrderJpa {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private String id;
    
    private String customerId;
    
    @Enumerated(EnumType.STRING)
    private OrderStatus status;
    
    @Embedded
    private MoneyJpa totalAmount;
    
    private LocalDateTime orderDate;
    
    @OneToMany(mappedBy = "order", cascade = {...}, fetch = FetchType.LAZY)
    private List<OrderItemJpa> items;
}
```

#### 3. Repository Interface (Domain)
**File**: `domain/repositories/OrderRepository.java`
```java
package <%= packageName %>.order.domain.repositories;

public interface OrderRepository {
    Order save(Order order);
    Optional<Order> findById(String id);
    List<Order> findAll();
    void deleteById(String id);
}
```

#### 4. JPA Repository (Spring Data)
**File**: `infrastructure/database/repositories/OrderJpaRepository.java`
```java
package <%= packageName %>.order.infrastructure.database.repositories;

import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderJpaRepository extends JpaRepository<OrderJpa, String> {
}
```

#### 5. Repository Implementation
**File**: `infrastructure/database/repositories/OrderRepositoryImpl.java`
```java
package <%= packageName %>.order.infrastructure.database.repositories;

@Component
public class OrderRepositoryImpl implements OrderRepository {
    private final OrderJpaRepository jpaRepository;
    private final OrderMapper mapper;
    
    @Override
    public Order save(Order order) {
        OrderJpa jpaEntity = mapper.toJpa(order);
        OrderJpa saved = jpaRepository.save(jpaEntity);
        return mapper.toDomain(saved);
    }
    // ... other methods
}
```

#### 6. Mapper (Domain â†” JPA)
**File**: `infrastructure/database/mappers/OrderMapper.java`
```java
package <%= packageName %>.order.infrastructure.database.mappers;

@Component
public class OrderMapper {
    public Order toDomain(OrderJpa jpa) { /* ... */ }
    public OrderJpa toJpa(Order domain) { /* ... */ }
    public List<Order> toDomainList(List<OrderJpa> jpaList) { /* ... */ }
}
```

#### 7. Value Object (Domain + JPA)
**File**: `domain/models/valueObjects/Money.java`
```java
public record Money(BigDecimal amount, String currency) {
    // Immutable value object
}
```

**File**: `infrastructure/database/valueObjects/MoneyJpa.java`
```java
@Embeddable
@Getter
@Setter
public class MoneyJpa {
    private BigDecimal amount;
    private String currency;
}
```

#### 8. Enum
**File**: `domain/models/enums/OrderStatus.java`
```java
public enum OrderStatus {
    DRAFT, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
}
```

---

## Key Commands

### Project Setup
```bash
# Create new project
eva4j create my-project

# Add a new module
eva4j add module order

# View project configuration
eva4j info
```

### Code Generation (must have domain.yaml)
```bash
# Generate entities from domain.yaml
eva4j generate entities order
eva4j g entities order         # Alias

# Generate CRUD REST API
eva4j g resource order          # Creates controller + DTOs + CRUD handlers

# Generate custom use case
eva4j g usecase order CreateCustomOrder
```

### Event-Driven Features
```bash
# Add Kafka client
eva4j add kafka-client

# Publish events
eva4j g kafka-event order order-created

# Consume events
eva4j g kafka-listener notification
```

### External API Integration
```bash
# Add HTTP client for external service
eva4j g http-exchange order payment-service
```

### Record Generation
```bash
# Generate record from JSON (clipboard or --json)
eva4j g record
```

### Microservice Extraction
```bash
# Extract module to independent microservice
eva4j detach order              # Creates ../order_msvc/ project
```

---

## CQRS Pattern Implementation

This project uses **CQRS (Command Query Responsibility Segregation)**.

### Commands (Write Operations)

**Command**: `application/commands/CreateOrderCommand.java`
```java
public record CreateOrderCommand(
    String customerId,
    List<CreateOrderItemDto> items
) implements Command {
}
```

**Handler**: `application/usecases/CreateOrderCommandHandler.java`
```java
@Service
public class CreateOrderCommandHandler implements CommandHandler<CreateOrderCommand, String> {
    private final OrderRepository orderRepository;
    
    @Override
    public String handle(CreateOrderCommand command) {
        // Business logic
        Order order = new Order(/* ... */);
        Order saved = orderRepository.save(order);
        return saved.getId();
    }
}
```

### Queries (Read Operations)

**Query**: `application/queries/GetOrderQuery.java`
```java
public record GetOrderQuery(String orderId) implements Query {
}
```

**Handler**: `application/usecases/GetOrderQueryHandler.java`
```java
@Service
public class GetOrderQueryHandler implements QueryHandler<GetOrderQuery, OrderResponseDto> {
    private final OrderRepository orderRepository;
    private final OrderApplicationMapper mapper;
    
    @Override
    public OrderResponseDto handle(GetOrderQuery query) {
        Order order = orderRepository.findById(query.orderId())
            .orElseThrow(() -> new NotFoundException("Order not found"));
        return mapper.toDto(order);
    }
}
```

### Dispatching via UseCaseMediator

**Controller**: `infrastructure/rest/controllers/OrderController.java`
```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    private final UseCaseMediator mediator;
    
    @PostMapping
    public ResponseEntity<String> createOrder(@RequestBody CreateOrderDto dto) {
        CreateOrderCommand command = new CreateOrderCommand(dto.customerId(), dto.items());
        String orderId = mediator.dispatch(command);
        return ResponseEntity.ok(orderId);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<OrderResponseDto> getOrder(@PathVariable String id) {
        GetOrderQuery query = new GetOrderQuery(id);
        OrderResponseDto response = mediator.dispatch(query);
        return ResponseEntity.ok(response);
    }
}
```

---

## ğŸ“ Patrones de CÃ³digo

### Mappers - ExclusiÃ³n de Campos de AuditorÃ­a

Los mappers **NO deben mapear campos de auditorÃ­a** en el builder:

```java
// âœ… CORRECTO - Excluye todos los campos de auditorÃ­a
public OrderJpa toJpa(Order domain) {
    return OrderJpa.builder()
        .id(domain.getId())
        .orderNumber(domain.getOrderNumber())
        .customerId(domain.getCustomerId())
        // NO mapear: createdAt, updatedAt, createdBy, updatedBy
        .build();
}

// âŒ INCORRECTO - Mapea campos de auditorÃ­a
public OrderJpa toJpa(Order domain) {
    return OrderJpa.builder()
        .id(domain.getId())
        .orderNumber(domain.getOrderNumber())
        .createdAt(domain.getCreatedAt())      // âŒ NO HACER
        .createdBy(domain.getCreatedBy())      // âŒ NO HACER
        .build();
}
```

**RazÃ³n:** Los campos de auditorÃ­a son heredados de clases base y JPA Auditing los popula automÃ¡ticamente.

### Filtro de Campos en Templates

Los templates excluyen automÃ¡ticamente campos de auditorÃ­a al generar mappers:

```javascript
// En generate-entities.js
const auditFields = ['createdAt', 'updatedAt', 'createdBy', 'updatedBy'];

const mappableFields = entity.fields.filter(f => 
    !auditFields.includes(f.name)
);
```

En los templates EJS, los campos se filtran asÃ­:

```ejs
<%%# En AggregateMapper.java.ejs %%>
<%% rootEntity.fields.filter(f => 
    !(f.name === 'createdAt' || 
      f.name === 'updatedAt' || 
      f.name === 'createdBy' || 
      f.name === 'updatedBy')
).forEach(field => { %%>
    .<%%= field.name %%>(domain.get<%%= field.name.charAt(0).toUpperCase() + field.name.slice(1) %%>())
<%% }); %%>
```

### Relaciones Bidireccionales

```java
// Entidad raÃ­z (User)
public void assignUserProfile(UserProfile profile) {
    this.userProfile = profile;
    if (profile != null) {
        profile.assignUser(this);  // Mantiene bidireccionalidad
    }
}

// Entidad secundaria (UserProfile)
void assignUser(User user) {  // package-private
    this.user = user;
}
```

**PatrÃ³n:** El mÃ©todo pÃºblico estÃ¡ en la raÃ­z del agregado, el mÃ©todo privado en la entidad secundaria.

---

## Adding New Features

### 1. Adding a New Entity to Existing Module

**Edit**: `modules/order/domain.yaml`

```yaml
aggregates:
  - name: Order
    entities:
      # ... existing entities ...
      
      - name: coupon              # âœ… Add new secondary entity
        tableName: coupons
        fields:
          - name: id
            type: String
          - name: code
            type: String
          - name: discount
            type: BigDecimal
```

**Regenerate**:
```bash
eva4j g entities order
```

### 2. Adding a New Enum

**Edit**: `modules/order/domain.yaml`

```yaml
aggregates:
  - name: Order
    # ...
    enums:
      - name: PaymentMethod       # âœ… Add new enum
        values:
          - CREDIT_CARD
          - DEBIT_CARD
          - CASH
          - BANK_TRANSFER
```

**Regenerate**:
```bash
eva4j g entities order
```

### 3. Adding a Custom Use Case

```bash
eva4j g usecase order CancelOrder
```

Creates:
- `application/commands/CancelOrderCommand.java`
- `application/usecases/CancelOrderCommandHandler.java`

**Implement business logic** in the handler:
```java
@Service
public class CancelOrderCommandHandler implements CommandHandler<CancelOrderCommand, Void> {
    private final OrderRepository orderRepository;
    
    @Override
    public Void handle(CancelOrderCommand command) {
        Order order = orderRepository.findById(command.orderId())
            .orElseThrow(() -> new NotFoundException("Order not found"));
        
        // Business logic
        if (order.getStatus() == OrderStatus.SHIPPED) {
            throw new BusinessException("Cannot cancel shipped order");
        }
        
        order.setStatus(OrderStatus.CANCELLED);
        orderRepository.save(order);
        return null;
    }
}
```

### 4. Adding Event Publishing

```bash
eva4j g kafka-event order order-cancelled
```

**Publish event** in use case:
```java
@Service
public class CancelOrderCommandHandler implements CommandHandler<CancelOrderCommand, Void> {
    private final OrderRepository orderRepository;
    private final KafkaTemplate<String, EventEnvelope<Map<String, Object>>> kafkaTemplate;
    
    @Value("${topics.order-cancelled}")
    private String orderCancelledTopic;
    
    @Override
    public Void handle(CancelOrderCommand command) {
        Order order = orderRepository.findById(command.orderId())
            .orElseThrow(() -> new NotFoundException("Order not found"));
        
        order.setStatus(OrderStatus.CANCELLED);
        orderRepository.save(order);
        
        // Publish event
        Map<String, Object> eventData = Map.of(
            "orderId", order.getId(),
            "customerId", order.getCustomerId(),
            "cancelledAt", LocalDateTime.now()
        );
        
        EventEnvelope<Map<String, Object>> event = new EventEnvelope<>(
            "OrderCancelled", "order-service", eventData
        );
        
        kafkaTemplate.send(orderCancelledTopic, event);
        return null;
    }
}
```

### 5. Adding Event Listener

```bash
eva4j g kafka-listener notification
# Select topics: order-cancelled
```

**Implement listener logic**:
```java
@Component("notificationOrderCancelledListener")
public class NotificationOrderCancelledListener {
    private final NotificationService notificationService;
    
    @KafkaListener(topics = "${topics.order-cancelled}")
    public void handle(EventEnvelope<Map<String, Object>> event, Acknowledgment ack) {
        String orderId = (String) event.data().get("orderId");
        String customerId = (String) event.data().get("customerId");
        
        notificationService.sendCancellationEmail(customerId, orderId);
        
        ack.acknowledge();
    }
}
```

---

## Conventions & Best Practices

### Naming Conventions

| Element                | Convention        | Example                    |
|------------------------|-------------------|----------------------------|
| Module name            | camelCase         | `order`, `userManagement`  |
| Aggregate name         | PascalCase        | `Order`, `UserProfile`     |
| Entity name (YAML)     | camelCase         | `order`, `orderItem`       |
| Generated class        | PascalCase        | `Order`, `OrderItem`       |
| Command/Query          | PascalCase + suffix | `CreateOrderCommand`     |
| Handler                | PascalCase + Handler | `CreateOrderCommandHandler` |
| Repository             | PascalCase + Repository | `OrderRepository`      |
| Controller             | PascalCase + Controller | `OrderController`      |
| DTO                    | PascalCase + Dto  | `OrderResponseDto`         |
| Value Object           | PascalCase        | `Money`, `Address`         |
| Enum                   | UPPER_SNAKE_CASE  | `CONFIRMED`, `SHIPPED`     |

### File Organization

**DO**:
- âœ… Keep domain entities pure (no annotations)
- âœ… Put business logic in domain entities/services
- âœ… Use value objects for concepts with multiple fields (Money, Address)
- âœ… Use DTOs for API contracts
- âœ… Map between layers explicitly

**DON'T**:
- âŒ Put business logic in controllers
- âŒ Use JPA entities in controllers/DTOs
- âŒ Mix domain and infrastructure concerns
- âŒ Bypass the repository for database access

### ID Generation Strategy

```yaml
# UUID (recommended for distributed systems)
fields:
  - name: id
    type: String          # â†’ @GeneratedValue(strategy = GenerationType.UUID)

# Auto-increment (traditional)
fields:
  - name: id
    type: Long            # â†’ @GeneratedValue(strategy = GenerationType.IDENTITY)
```

### Relationship Best Practices

**Bidirectional relationships are auto-generated**:
```yaml
# âœ… Define only the parent side
relationships:
  - type: OneToMany
    target: OrderItem
    mappedBy: order
    cascade: [PERSIST, MERGE, REMOVE]
    fetch: LAZY

# âŒ DO NOT define the inverse ManyToOne in OrderItem
# eva4j generates it automatically!
```

**Use `LAZY` fetch by default**:
```yaml
relationships:
  - type: OneToMany
    target: OrderItem
    mappedBy: order
    cascade: [PERSIST, MERGE, REMOVE]
    fetch: LAZY          # âœ… Prevents N+1 queries
```

**Cascade operations carefully**:
- `PERSIST`: Save children when saving parent
- `MERGE`: Update children when updating parent
- `REMOVE`: Delete children when deleting parent
- `REFRESH`: Reload children when reloading parent
- `DETACH`: Detach children when detaching parent
- `ALL`: All of the above

---

## ï¿½ Referencia de Tipos

### Tipos de Datos Soportados

| Tipo YAML | Tipo Java | Observaciones |
|-----------|-----------|---------------|
| String | String | Texto |
| Integer | Integer | NÃºmeros enteros |
| Long | Long | NÃºmeros enteros largos |
| BigDecimal | BigDecimal | PrecisiÃ³n decimal |
| Boolean | Boolean | true/false |
| LocalDate | LocalDate | Fecha sin hora |
| LocalDateTime | LocalDateTime | Fecha y hora |
| LocalTime | LocalTime | Solo hora |
| Instant | Instant | Timestamp UTC |
| UUID | UUID | Identificador Ãºnico |

### Tipos de Relaciones

- `OneToOne` - RelaciÃ³n uno a uno
- `OneToMany` - RelaciÃ³n uno a muchos
- `ManyToOne` - RelaciÃ³n muchos a uno
- `ManyToMany` - RelaciÃ³n muchos a muchos (evitar si es posible)

### Estrategias de Cascade

```yaml
cascade: [PERSIST]         # Solo propagar guardado
cascade: [PERSIST, MERGE]  # Propagar guardado y actualizaciÃ³n
cascade: [ALL]             # Propagar todas las operaciones
cascade: [PERSIST, MERGE, REMOVE]  # MÃ¡s comÃºn para agregados
```

### Estrategias de Fetch

```yaml
fetch: LAZY    # âœ… Recomendado - Carga bajo demanda
fetch: EAGER   # âš ï¸ Usar con cuidado - Carga inmediata
```

---

## ï¿½ğŸ”„ Flujo de Datos

### Escritura (Command)

```
HTTP Request
    â†“
Controller (REST)
    â†“
CommandHandler (Application)
    â†“
ApplicationMapper (DTO â†’ Domain)
    â†“
Domain Entity (Business Logic)
    â†“
Repository Interface (Domain)
    â†“
RepositoryImpl (Infrastructure)
    â†“
AggregateMapper (Domain â†’ JPA)
    â†“
JPA Repository
    â†“
Database
```

**CaracterÃ­sticas del flujo de escritura:**
- Los campos de auditorÃ­a (`createdAt`, `updatedAt`, `createdBy`, `updatedBy`) **NO se mapean** en AggregateMapper
- JPA Auditing popula automÃ¡ticamente estos campos al guardar
- `UserContextFilter` captura header `X-User` y lo almacena en `UserContextHolder`
- `AuditorAwareImpl` consulta `UserContextHolder` para `createdBy`/`updatedBy`

### Lectura (Query)

```
HTTP Request
    â†“
Controller (REST)
    â†“
QueryHandler (Application)
    â†“
Repository Interface (Domain)
    â†“
RepositoryImpl (Infrastructure)
    â†“
JPA Repository
    â†“
AggregateMapper (JPA â†’ Domain)
    â†“
ApplicationMapper (Domain â†’ DTO)
    â†“
HTTP Response (sin createdBy/updatedBy)
```

**CaracterÃ­sticas del flujo de lectura:**
- ApplicationMapper **excluye** `createdBy` y `updatedBy` del DTO de respuesta
- Solo expone `createdAt` y `updatedAt` (timestamps pÃºblicos)
- `createdBy`/`updatedBy` son metadatos administrativos internos

---

## Configuration Management

### Environment-Specific Configuration

Configuration is split by environment:

**Main**: `resources/application.yaml`
```yaml
spring:
  profiles:
    active: ${PROFILE:local}
  config:
    import:
      - optional:classpath:application-${spring.profiles.active}.yaml
```

**Environment files**:
- `application-local.yaml` (development)
- `application-develop.yaml` (dev server)
- `application-test.yaml` (testing)
- `application-production.yaml` (production)

Each imports environment-specific parameters:
```yaml
spring:
  config:
    import:
      - optional:classpath:parameters/${spring.profiles.active}/db.yaml
      - optional:classpath:parameters/${spring.profiles.active}/cors.yaml
```

### Database Configuration

**File**: `resources/parameters/local/db.yaml`
```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/<%= artifactId %>_db
    username: postgres
    password: postgres
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
```

### Kafka Configuration

**File**: `resources/parameters/local/kafka.yaml`
```yaml
spring:
  kafka:
    bootstrap-servers: localhost:9092
    consumer:
      group-id: <%= artifactId %>-consumer

topics:
  order-created: order.events.created
  order-cancelled: order.events.cancelled
```

---

## ğŸš¨ Errores Comunes a Evitar

### âŒ NO Crear Constructor VacÃ­o en Dominio

```java
// âŒ INCORRECTO
public class User {
    public User() {  // NO HACER
    }
}

// âœ… CORRECTO
public class User {
    public User(String username, String email) {
        this.username = username;
        this.email = email;
    }
}
```

### âŒ NO Agregar Setters en Dominio

```java
// âŒ INCORRECTO
public void setUsername(String username) {
    this.username = username;
}

// âœ… CORRECTO
public void changeUsername(String newUsername) {
    if (newUsername == null || newUsername.isEmpty()) {
        throw new IllegalArgumentException("Username cannot be empty");
    }
    this.username = newUsername;
}
```

### âŒ NO Mapear Campos de AuditorÃ­a

```java
// âŒ INCORRECTO
public UserJpa toJpa(User domain) {
    return UserJpa.builder()
        .id(domain.getId())
        .createdBy(domain.getCreatedBy())  // NO HACER
        .updatedBy(domain.getUpdatedBy())  // NO HACER
        .build();
}

// âœ… CORRECTO
public UserJpa toJpa(User domain) {
    return UserJpa.builder()
        .id(domain.getId())
        // NO mapear campos de auditorÃ­a
        .build();
}
```

### âŒ NO Exponer createdBy/updatedBy en DTOs

```java
// âŒ INCORRECTO
public record UserResponseDto(
    String id,
    String username,
    String createdBy,   // NO exponer
    String updatedBy    // NO exponer
) {}

// âœ… CORRECTO
public record UserResponseDto(
    String id,
    String username,
    LocalDateTime createdAt,   // SÃ exponer
    LocalDateTime updatedAt    // SÃ exponer
) {}
```

---

## ğŸ¯ Mejores PrÃ¡cticas para Agentes

### Al Generar CÃ³digo de Dominio

1. **NUNCA** crear constructor vacÃ­o en entidades de dominio
2. **NUNCA** agregar setters pÃºblicos
3. **SIEMPRE** crear mÃ©todos de negocio para modificar estado
4. **SIEMPRE** validar en mÃ©todos de negocio, no en constructores
5. **SIEMPRE** mantener inmutabilidad en Value Objects

### Al Generar CÃ³digo JPA

1. **SIEMPRE** usar Lombok (`@Getter`, `@Setter`, `@Builder`)
2. **SIEMPRE** extender clase base correcta segÃºn auditorÃ­a:
   - Sin auditorÃ­a: ninguna clase base
   - `audit.enabled: true`: extender `AuditableEntity`
   - `audit.trackUser: true`: extender `FullAuditableEntity`
3. **NUNCA** incluir campos de auditorÃ­a heredados en `@Builder`
4. **SIEMPRE** usar `@NoArgsConstructor` para JPA

### Al Generar Mappers

1. **NUNCA** mapear campos de auditorÃ­a (createdAt, updatedAt, createdBy, updatedBy)
2. **SIEMPRE** filtrar campos antes de usar `.builder()`
3. **SIEMPRE** mapear bidireccionalidad en relaciones

### Al Generar DTOs

1. **NUNCA** exponer `createdBy` y `updatedBy` en respuestas
2. **SIEMPRE** exponer `createdAt` y `updatedAt`
3. **SIEMPRE** usar Java Records para DTOs
4. **SIEMPRE** filtrar campos al crear contextos de template

---

## âœ… Checklist para Agentes

Al generar o modificar cÃ³digo, verificar:

- [ ] Entidades de dominio **sin constructor vacÃ­o**
- [ ] Entidades de dominio **sin setters pÃºblicos**
- [ ] MÃ©todos de negocio con **validaciones explÃ­citas**
- [ ] Entidades JPA con **Lombok y herencia correcta**
- [ ] Mappers **excluyen campos de auditorÃ­a**
- [ ] DTOs de respuesta **sin createdBy/updatedBy**
- [ ] Relaciones bidireccionales con mÃ©todos `assign*()`
- [ ] Value Objects **inmutables**
- [ ] ConfiguraciÃ³n de auditorÃ­a cuando `audit.trackUser: true`

---

## Important Notes for AI Agents

### Code Generation Flow

1. **domain.yaml is the source of truth** for domain models
2. **Never edit generated files** directly (domain/models/entities, infrastructure/database/entities)
3. **Always regenerate** after modifying domain.yaml: `eva4j g entities <module>`
4. **Hand-written code** goes in:
   - Application layer (use cases, commands, queries)
   - Domain services
   - Infrastructure adapters

### Safe to Modify

- âœ… Use case handlers (application/usecases)
- âœ… Commands and queries (application/commands, application/queries)
- âœ… Controllers (infrastructure/rest/controllers)
- âœ… DTOs (application/dtos)
- âœ… Domain services (domain/services)
- âœ… Configuration files

### Do Not Modify (Generated)

- âŒ Domain entities (domain/models/entities)
- âŒ JPA entities (infrastructure/database/entities)
- âŒ Repository interfaces (domain/repositories)
- âŒ Repository implementations (infrastructure/database/repositories)
- âŒ Mappers (infrastructure/database/mappers)

### Documentation References

- **[DOMAIN_YAML_GUIDE.md](https://github.com/asuridev/eva4j)**: Complete domain.yaml syntax reference
- **[eva4j CLI Documentation](https://github.com/asuridev/eva4j/tree/main/docs/commands)**: Detailed command documentation
- **[Examples](https://github.com/asuridev/eva4j/tree/main/examples)**: Sample domain.yaml files

---

## Quick Command Reference

```bash
# Project management
eva4j create <project>              # Create new project
eva4j add module <name>             # Add module
eva4j info                          # View config

# Code generation
eva4j g entities <module>           # Generate from domain.yaml
eva4j g resource <module>           # Generate CRUD REST
eva4j g usecase <module> <name>     # Add custom use case
eva4j g record                      # Generate record from JSON

# Event-driven
eva4j add kafka-client              # Enable Kafka
eva4j g kafka-event <mod> <event>   # Publish events
eva4j g kafka-listener <module>     # Consume events

# External integration
eva4j g http-exchange <mod> <api>   # External API client

# Microservices
eva4j detach <module>               # Extract to microservice
```

---

**Generated by eva4j CLI** - Version <%= version || '1.0.0' %>  
For more information, visit: https://github.com/asuridev/eva4j
